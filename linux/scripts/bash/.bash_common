set -CEeuo pipefail


script_path=$(cd -- "$(dirname -- "${BASH_SOURCE[-1]}")" &> /dev/null && pwd)
script_name=$(basename "${BASH_SOURCE[-1]}")


################################################################################
### Log
################################################################################

: "${LOG_WITH_COLOR:=true}"

_log() {
  local color_setup="\033[${2};3${1}m"; shift; shift
  local color_reset="\033[0m"
  local msg="${@}";
  if ! ${LOG_WITH_COLOR}; then color_setup=""; fi
  printf "${color_setup}${msg}${color_reset}\n" >&2
}

log_header() { _log 3 1 "@ ${@}";   }  # Yellow : 3 | Bold : 1
log_info()   { _log 2 0 ">> ${@}";  }  # Green  : 2 | Thin : 0
log_warn()   { _log 5 0 "W · ${@}"; }  # Purple : 5 | Thin : 0
log_error()  { _log 1 0 "E · ${@}"; }  # Red    : 1 | Thin : 0
error_exit() { log_error "${@}"; exit 1; }


################################################################################
### Required
################################################################################

: "${REQUIRED_VERBOSE:=false}"

declare -A _REQUIRED_LABELS=(
  [file]="File"
  [dir]="Dir"
  [var]="Var"
  [cmd]="Cmd"
  [notemptydir]="NotEmptyDir"
)

_required() {
  local op="${1,,}" elem="$2" info="${3:-}"
  local label="${_REQUIRED_LABELS[$op]:-$op}"

  if ! _is "$op" "$elem"; then
    error_exit "${label} not found '${elem}'${info:+ <-- $info}"
  elif ${REQUIRED_VERBOSE}; then
    log_info "${label} found '${elem}'"
  fi
}

_is() {
  local op="${1,,}"
  local elem="$2"
  case "${op}" in
    file)        [[ -f "${elem}" ]] && return 0 ;;
    dir)         [[ -d "${elem}" ]] && return 0 ;;
    var)         [[ -n "${elem}" ]] && return 0 ;;
    cmd)         command -v "${elem}" >/dev/null 2>&1 && return 0 ;;
    notemptydir) [[ -d "${elem}" ]] && [[ -n "$(ls -A "${elem}" 2>/dev/null)" ]] && return 0 ;;
  esac
  return 1;
}

for type in "${!_REQUIRED_LABELS[@]}"; do
  eval "is_${type}() { _is '${type}' \"\$@\"; }"
  eval "required_${type}() { _required '${type}' \"\$@\"; }"
done


################################################################################
### Git
################################################################################

is_git() {
  required_cmd "git"
  git rev-parse --is-inside-work-tree > /dev/null 2>&1
}
guard__is_git() {
  is_git || error_exit "Current directory is not a git repository"
}

repo_root() {
  echo "$(git -C "${script_path}" rev-parse --show-toplevel 2>/dev/null)"
}
repo_parent() {
  local root="$(repo_root)"
  [[ -n "${root}" ]] && echo "$(dirname "${root}")" || echo "${script_path}"
}
repo_branch() {
  echo "$(git -C "${script_path}" branch --show-current)"
}


################################################################################
### Interactive
################################################################################

_find_dir_name_only() {
  local dir="${1}" pattern="${2:-*}"
  find "${dir}" -mindepth 1 -maxdepth 1 -type d -name "${pattern}" -printf '%P\n'
}

choose_one() {
  required_cmd "fzf"
  local prompt="Choose one"
  #! Args
  while [[ "${#}" > 0 ]]; do
      case "${1}" in
          -p | --prompt ) shift; [[ "${1:-}" =~ ^[^-] ]] && prompt="${1}" || error_exit "Missing prompt (?)"; shift ;;
          --            ) shift; break ;;
          *             ) break;;
      esac
  done
  #! Input
  [[ ! -t 0 ]] && readarray -t fzf_input || fzf_input=("${@}")
  [[ ${#fzf_input[@]} > 0 ]] || error_exit "Nothing to choose from"
  #! Command
  printf "%s\n" "${fzf_input[@]}" | fzf -1 --prompt="${prompt:+$prompt > }" --layout=reverse --cycle --info=inline-right --height $(min $(tput lines) 20)
}
choose_from_dir() {
  [[ "${#}" > 0 ]] || error_exit "Usage: choose_from_dir DIR"
  echo "${1}/$(choose_from_dir_tail "${1}")"
}
choose_from_dir_tail() {
  [[ "${#}" > 0 ]] || error_exit "Usage: choose_from_dir_tail DIR"
  choose_one "$(_find_dir_name_only "${1}")"
}
choose_from_dir_glob() {
  [[ "${#}" > 1 ]] || error_exit "Usage: choose_from_dir_glob DIR PATTERN"
  choose_one "${1}/$(_find_dir_name_only "${1}" "${2}")"
}


################################################################################
### Misc
################################################################################

show_and_copy() {
  echo "$1"
  if is_cmd "xclip"; then
    echo "$1" | xclip -selection c
  fi
}

max() {
  echo $(( $1 > $2 ? $1 : $2 ))
}
min() {
  echo $(( $1 < $2 ? $1 : $2 ))
}
clamp() {
  min $(max $1 $2) $3  # value, low, high
}
